/*******************************************************************************
* Copyright (C) 2019-2023 Maxim Integrated Products, Inc., All rights Reserved.
*
* This software is protected by copyright laws of the United States and
* of foreign countries. This material may also be protected by patent laws
* and technology transfer regulations of the United States and of foreign
* countries. This software is furnished under a license agreement and/or a
* nondisclosure agreement and may only be used or reproduced in accordance
* with the terms of those agreements. Dissemination of this information to
* any party or parties not specified in the license agreement and/or
* nondisclosure agreement is expressly prohibited.
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
* OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* Except as contained in this notice, the name of Maxim Integrated
* Products, Inc. shall not be used except as stated in the Maxim Integrated
* Products, Inc. Branding Policy.
*
* The mere transfer of this software does not imply any licenses
* of trade secrets, proprietary technology, copyrights, patents,
* trademarks, maskwork rights, or any other form of intellectual
* property whatsoever. Maxim Integrated Products, Inc. retains all
* ownership rights.
*******************************************************************************/

// final-proj
// This file was @generated by ai8xize.py --verbose --test-dir demos --prefix final-proj --checkpoint-file trained/proj-final.pth.tar --config-file networks/final-mnist.yaml --device MAX78000 --compact-data --softmax --overwrite

#include <stdint.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
#include "sampledata.h"
#include "uart.h"
#include "nvic_table.h"
#include "UART_KC.h"
#include "Push_Button.h"

#define _BV(bit) 				(1 << (bit))
#define PRINT_REG(x)			(printf("%x/n"), *((volatile uint32_t *) x))
#define INPUT_SIZE				RX_SIZE/4
#define TEST_SIZE				10000 + 1//ALways 1 more than the .py file for some reason

// 1-channel 28x28 data input (784 bytes / 196 32-bit words):
// CHW 28x28, channel 0
//static const uint32_t input_0[] = SAMPLE_INPUT_0;

volatile uint32_t cnn_time; // Stopwatch
static int32_t input_0[INPUT_SIZE] = SAMPLE_INPUT_0; // Stores Signed values of input
static uint8_t buffer[RX_SIZE] = {}; // To store bytes of data
static uint8_t output[TX_SIZE] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19, 20, 21};

void load_input(void)
{
	for(uint32_t i = INPUT_SIZE - 1; i > 0; --i)
	{
		input_0[i] = (uint32_t) buffer[i*4] << 24 | (uint32_t) buffer[i*4 +1] << 16 | (uint32_t) buffer[i*4 +2] << 8 | (uint32_t) buffer[i*4 +3];
	}
	memcpy32((uint32_t *) 0x50400000, input_0, 196); // Solve this
}

// Classification layer:
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];

void softmax_layer(void)
{
  cnn_unload((uint32_t *) ml_data);
  softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
}

int main(void)
{	//J1_1 to orange, J1_0 to Yellow
	int digs, tens, perc;

	MXC_ICC_Enable(MXC_ICC0); // Enable cache

	// Switch to 100 MHz clock
	MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
	SystemCoreClockUpdate();

	printf("Waiting...\n");

	// DO NOT DELETE THIS LINE:
	MXC_Delay(SEC(2)); // Let debugger interrupt if needed

	cnn_disable(); // Disable clock and power to CNN
	// Enable primary clock
	MXC_SYS_ClockSourceEnable(MXC_SYS_CLOCK_IPO);

	printf("\nMeasuring system base (idle) power...\n");
	SYS_START;
	MXC_Delay(SEC(1));
	SYS_COMPLETE;

	// Enable peripheral, enable CNN interrupt, turn on CNN clock
	// CNN clock: APB (50 MHz) div 1
	cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

	// *************** Initiating all UART Functions and Peripherals ***************
	cnn_init(); // Bring state machine into consistent state
	init_UART();
	UART_setup(buffer, output);
	initiate_PB();

	printf("Measuring weight loading...\n");
	CNN_START;
	for (uint8_t i = 0; i < 100; i++)
	  cnn_load_weights(); // Load kernels
	CNN_COMPLETE;

	MXC_TMR_Delay(MXC_TMR0, 500000);
	printf("Measuring input loading...\n");
	CNN_START;
	for (uint8_t i = 0; i < 100; i++)
	  load_input(); // Load data input
	CNN_COMPLETE;

	printf("\n*** CNN Inference Test final-proj-2 for Dynamic System ***\n");
	for(int x = 0; x < TEST_SIZE; ++x)
	{
		printf("\nPlease select the percentage using PB1, and confirm using PB2\n");
		perc = button_pushed();

		printf("\nThe selected percentage is %d%\n", perc);
		cnn_load_bias(); // Not used in this network
		cnn_configure(perc); // Configure state machine

		printf("\n********** Test Number: %d **********\n", x+1);

		UART_start(); // Starts communication

		printf("Measuring input load + inference...\n");
		CNN_START; // Allow capture of processing time
		for (uint8_t i = 0; i < 100; i++) {
		  load_input(); // Load data input
		  cnn_start(); // Run inference
		  while (cnn_time == 0)
		    MXC_LP_EnterSleepMode(); // Wait for CNN
		 }
		CNN_COMPLETE;
		softmax_layer();

		printf("\n*** PASS ***\n\n");

		#ifdef CNN_INFERENCE_TIMER
		printf("Approximate inference time: %u us\n\n", cnn_time);
		#endif
		printf("See monitor display for inference energy.\n\n");

		printf("\nProducing results.....................\n");

		// Data is prepared for Transmission
		printf("Classification results:\n");
		for (uint8_t i = 0; i < CNN_NUM_OUTPUTS; i++) {
		  digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
		  tens = digs % 10;
		  digs = digs / 10;
		  printf("[%7d] -> Class %d: %d.%d%%\n", ml_data[i], i, digs, tens);
		  output[i] = (uint8_t) digs;
		  output[i+10] = (uint8_t) tens;
		}
		output[20] = (uint8_t) (((uint16_t) cnn_time & 0xff00) >> 8);
		output[21] = (uint8_t) ((uint16_t) cnn_time & 0x00ff);

		printf("\n********** End of Test %d **********\n", x+1);
	}

	cnn_disable();
	printf("Finished");
	return 0;
}

/*
  SUMMARY OF OPS
  Hardware: 25,461,732 ops (25,331,640 macc; 130,092 comp; 0 add; 0 mul; 0 bitwise)
    Layer 0 (conv1_Conv_2): 432,640 ops (389,376 macc; 43,264 comp; 0 add; 0 mul; 0 bitwise)
    Layer 1 (conv2_Conv_2): 21,270,528 ops (21,233,664 macc; 36,864 comp; 0 add; 0 mul; 0 bitwise)
    Layer 2 (conv3_Conv_2): 3,729,664 ops (3,686,400 macc; 43,264 comp; 0 add; 0 mul; 0 bitwise)
    Layer 3 (conv4_Conv_2): 25,900 ops (19,200 macc; 6,700 comp; 0 add; 0 mul; 0 bitwise)
    Layer 4 (fc_MatMul_3): 3,000 ops (3,000 macc; 0 comp; 0 add; 0 mul; 0 bitwise)

  RESOURCE USAGE
  Weight memory: 78,072 bytes out of 442,368 bytes total (17.6%)
  Bias memory:   0 bytes out of 2,048 bytes total (0.0%)
*/

